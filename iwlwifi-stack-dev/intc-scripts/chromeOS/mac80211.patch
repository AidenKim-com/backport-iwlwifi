diff --git a/net/mac80211/Makefile b/net/mac80211/Makefile
index e44def91bb..446cdefc96 100644
--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CPTCFG_MAC80211) += mac80211.o
+obj-$(CPTCFG_MAC80211) += iwl7000_mac80211.o
 
 ifeq ($(CPTCFG_IWLWIFI_SIMULATION),y)
 UBSAN_SANITIZE := y
@@ -61,6 +61,9 @@ mac80211-$(CONFIG_PM) += pm.o
 CFLAGS_trace.o := -I$(src)
 subdir-ccflags-y += $(call cc-option,-Wimplicit-fallthrough)
 
+CFLAGS_tx.o += -include "hdrs/iwl-tx.h"
+CFLAGS_debugfs.o += -include "hdrs/net/fq.h"
+
 rc80211_minstrel-y := \
 	rc80211_minstrel_ht.o
 
@@ -70,3 +73,7 @@ rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
 
 ccflags-y += -DDEBUG
+
+mac80211-y += backports.o cfg-utils.o
+
+iwl7000_mac80211-objs := $(mac80211-objs) $(mac80211-y)
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index f6f9fabcc9..7fd9a66161 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -29,6 +29,7 @@ static void ieee80211_set_mu_mimo_follow(struct ieee80211_sub_if_data *sdata,
 	bool mu_mimo_groups = false;
 	bool mu_mimo_follow = false;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,12,0)
 	if (params->vht_mumimo_groups) {
 		u64 membership;
 
@@ -46,6 +47,7 @@ static void ieee80211_set_mu_mimo_follow(struct ieee80211_sub_if_data *sdata,
 		       WLAN_MEMBERSHIP_LEN);
 		mu_mimo_groups = membership != 0;
 	}
+#endif
 
 	if (params->vht_mumimo_follow_addr) {
 		mu_mimo_follow =
@@ -403,6 +405,7 @@ static int ieee80211_set_noack_map(struct wiphy *wiphy,
 	return 0;
 }
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
 static int ieee80211_set_tx(struct ieee80211_sub_if_data *sdata,
 			    const u8 *mac_addr, u8 key_idx)
 {
@@ -432,6 +435,7 @@ static int ieee80211_set_tx(struct ieee80211_sub_if_data *sdata,
 	mutex_unlock(&local->key_mtx);
 	return ret;
 }
+#endif
 
 static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 			     u8 key_idx, bool pairwise, const u8 *mac_addr,
@@ -446,9 +450,10 @@ static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 	if (!ieee80211_sdata_running(sdata))
 		return -ENETDOWN;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
 	if (pairwise && params->mode == NL80211_KEY_SET_TX)
 		return ieee80211_set_tx(sdata, mac_addr, key_idx);
-
+#endif
 	/* reject WEP and TKIP keys if WEP failed to initialize */
 	switch (params->cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
@@ -469,9 +474,10 @@ static int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 	if (pairwise)
 		key->conf.flags |= IEEE80211_KEY_FLAG_PAIRWISE;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
 	if (params->mode == NL80211_KEY_NO_TX)
 		key->conf.flags |= IEEE80211_KEY_FLAG_NO_AUTO_TX;
-
+#endif
 	mutex_lock(&local->sta_mtx);
 
 	if (mac_addr) {
@@ -780,8 +786,9 @@ void sta_set_rate_info_tx(struct sta_info *sta,
 }
 
 static int ieee80211_dump_station(struct wiphy *wiphy, struct net_device *dev,
-				  int idx, u8 *mac, struct station_info *sinfo)
+				  int idx, u8 *mac, cfg_station_info_t *cfginfo)
 {
+	struct station_info _sinfo = {}, *sinfo = &_sinfo;
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta;
@@ -798,20 +805,27 @@ static int ieee80211_dump_station(struct wiphy *wiphy, struct net_device *dev,
 
 	mutex_unlock(&local->sta_mtx);
 
+	iwl7000_convert_sinfo(sinfo, cfginfo);
+
 	return ret;
 }
 
 static int ieee80211_dump_survey(struct wiphy *wiphy, struct net_device *dev,
-				 int idx, struct survey_info *survey)
+				 int idx, cfg_survey_info_t *cfgsurvey)
 {
 	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct survey_info _survey = {}, *survey = &_survey;
+	int ret;
 
-	return drv_get_survey(local, idx, survey);
+	ret = drv_get_survey(local, idx, survey);
+	iwl7000_convert_survey_info(survey, cfgsurvey);
+	return ret;
 }
 
 static int ieee80211_get_station(struct wiphy *wiphy, struct net_device *dev,
-				 const u8 *mac, struct station_info *sinfo)
+				 const u8 *mac, cfg_station_info_t *cfginfo)
 {
+	struct station_info _sinfo = {}, *sinfo = &_sinfo;
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
 	struct ieee80211_local *local = sdata->local;
 	struct sta_info *sta;
@@ -827,6 +841,8 @@ static int ieee80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 
 	mutex_unlock(&local->sta_mtx);
 
+	iwl7000_convert_sinfo(sinfo, cfginfo);
+
 	return ret;
 }
 
@@ -1189,7 +1205,12 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 			      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);
 		changed |= BSS_CHANGED_HE_OBSS_PD;
 
+
+#if CFG80211_VERSION >= KERNEL_VERSION(5,19,0)
 		if (params->beacon.he_bss_color.enabled)
+#elif CFG80211_VERSION >= KERNEL_VERSION(5,4,0)
+		if (params->he_bss_color.enabled)
+#endif
 			changed |= BSS_CHANGED_HE_BSS_COLOR;
 	}
 
@@ -1238,11 +1259,19 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 	link_conf->dtim_period = params->dtim_period;
 	link_conf->enable_beacon = true;
 	link_conf->allow_p2p_go_ps = sdata->vif.p2p;
+#if CFG80211_VERSION >= KERNEL_VERSION(5,5,0)
 	link_conf->twt_responder = params->twt_responder;
 	link_conf->he_obss_pd = params->he_obss_pd;
+#endif
+#if CFG80211_VERSION >= KERNEL_VERSION(5,19,0)
 	link_conf->he_bss_color = params->beacon.he_bss_color;
+#elif CFG80211_VERSION >= KERNEL_VERSION(5,4,0)
+	link_conf->he_bss_color = params->he_bss_color;
+#endif
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 	sdata->vif.cfg.s1g = params->chandef.chan->band ==
 				  NL80211_BAND_S1GHZ;
+#endif
 
 	sdata->vif.cfg.ssid_len = params->ssid_len;
 	if (params->ssid_len)
@@ -1259,6 +1288,7 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 		link_conf->p2p_noa_attr.oppps_ctwindow |=
 					IEEE80211_P2P_OPPPS_ENABLE_BIT;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 	sdata->beacon_rate_set = false;
 	if (wiphy_ext_feature_isset(local->hw.wiphy,
 				    NL80211_EXT_FEATURE_BEACON_RATE_LEGACY)) {
@@ -1269,15 +1299,19 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 				sdata->beacon_rate_set = true;
 		}
 	}
+#endif
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 	if (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))
 		link_conf->beacon_tx_rate = params->beacon_rate;
+#endif
 
 	err = ieee80211_assign_beacon(sdata, link, &params->beacon, NULL, NULL);
 	if (err < 0)
 		goto error;
 	changed |= err;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 	if (params->fils_discovery.max_interval) {
 		err = ieee80211_set_fils_discovery(sdata,
 						   &params->fils_discovery,
@@ -1295,6 +1329,7 @@ static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 			goto error;
 		changed |= BSS_CHANGED_UNSOL_BCAST_PROBE_RESP;
 	}
+#endif
 
 	err = drv_start_ap(sdata->local, sdata, link_conf);
 	if (err) {
@@ -1356,11 +1391,13 @@ static int ieee80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,
 	if (err < 0)
 		return err;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,19,0)
 	if (params->he_bss_color_valid &&
 	    params->he_bss_color.enabled != link_conf->he_bss_color.enabled) {
 		link_conf->he_bss_color.enabled = params->he_bss_color.enabled;
 		err |= BSS_CHANGED_HE_BSS_COLOR;
 	}
+#endif
 
 	ieee80211_link_info_change_notify(sdata, link, err);
 	return 0;
@@ -1598,18 +1635,27 @@ static void sta_apply_mesh_params(struct ieee80211_local *local,
 
 static int sta_link_apply_parameters(struct ieee80211_local *local,
 				     struct sta_info *sta, bool new_link,
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 				     struct link_station_parameters *params)
+#else
+				     struct station_parameters *params)
+#endif
 {
 	int ret = 0;
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	u32 link_id = params->link_id < 0 ? 0 : params->link_id;
+#else
+	u32 link_id = 0;
+#endif
 	struct ieee80211_link_data *link =
 		sdata_dereference(sdata->link[link_id], sdata);
 	struct link_sta_info *link_sta =
 		rcu_dereference_protected(sta->link[link_id],
 					  lockdep_is_held(&local->sta_mtx));
 
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	/*
 	 * If there are no changes, then accept a link that doesn't exist,
 	 * unless it's a new link.
@@ -1621,6 +1667,7 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,
 	    !params->he_capa && !params->eht_capa &&
 	    !params->opmode_notif_used)
 		return 0;
+#endif
 
 	if (!link || !link_sta)
 		return -EINVAL;
@@ -1629,6 +1676,7 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,
 	if (!sband)
 		return -EINVAL;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	if (params->link_mac) {
 		if (new_link) {
 			memcpy(link_sta->addr, params->link_mac, ETH_ALEN);
@@ -1640,8 +1688,14 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,
 	} else if (new_link) {
 		return -EINVAL;
 	}
+#endif
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	if (params->txpwr_set) {
+#else
+	if (params->sta_modify_mask & STATION_PARAM_APPLY_STA_TXPOWER) {
+#endif
 		link_sta->pub->txpwr.type = params->txpwr.type;
 		if (params->txpwr.type == NL80211_TX_POWER_LIMITED)
 			link_sta->pub->txpwr.power = params->txpwr.power;
@@ -1649,7 +1703,7 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,
 		if (ret)
 			return ret;
 	}
-
+#endif
 	if (params->supported_rates &&
 	    params->supported_rates_len) {
 		ieee80211_parse_bitrates(link->conf->chandef.width,
@@ -1667,13 +1721,20 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,
 		ieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,
 						    params->vht_capa, link_sta);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,19,0)
 	if (params->he_capa)
 		ieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,
 						  (void *)params->he_capa,
 						  params->he_capa_len,
+#if CFG80211_VERSION >= KERNEL_VERSION(99,0,0)
 						  (void *)params->he_6ghz_capa,
+#else
+						  NULL,
+#endif
 						  link_sta);
+#endif
 
+#if CFG80211_VERSION >= KERNEL_VERSION(9,9,9)
 	if (params->eht_capa)
 		ieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,
 						    (u8 *)params->he_capa,
@@ -1681,6 +1742,7 @@ static int sta_link_apply_parameters(struct ieee80211_local *local,
 						    params->eht_capa,
 						    params->eht_capa_len,
 						    link_sta);
+#endif
 
 	if (params->opmode_notif_used) {
 		/* returned value is only needed for rc update, but the
@@ -1804,8 +1866,12 @@ static int sta_apply_parameters(struct ieee80211_local *local,
 	if (params->listen_interval >= 0)
 		sta->listen_interval = params->listen_interval;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	ret = sta_link_apply_parameters(local, sta, false,
 					&params->link_sta_params);
+#else
+	ret = sta_link_apply_parameters(local, sta, false, params);
+#endif
 	if (ret)
 		return ret;
 
@@ -1815,8 +1881,10 @@ static int sta_apply_parameters(struct ieee80211_local *local,
 	if (ieee80211_vif_is_mesh(&sdata->vif))
 		sta_apply_mesh_params(local, sta, params);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,1,0)
 	if (params->airtime_weight)
 		sta->airtime_weight = params->airtime_weight;
+#endif
 
 	/* set the STA state after all sta info from usermode has been set */
 	if (test_sta_flag(sta, WLAN_STA_TDLS_PEER) ||
@@ -2300,6 +2368,7 @@ static int copy_mesh_setup(struct ieee80211_if_mesh *ifmsh,
 	sdata->vif.bss_conf.beacon_int = setup->beacon_interval;
 	sdata->vif.bss_conf.dtim_period = setup->dtim_period;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 	sdata->beacon_rate_set = false;
 	if (wiphy_ext_feature_isset(sdata->local->hw.wiphy,
 				    NL80211_EXT_FEATURE_BEACON_RATE_LEGACY)) {
@@ -2310,6 +2379,7 @@ static int copy_mesh_setup(struct ieee80211_if_mesh *ifmsh,
 				sdata->beacon_rate_set = true;
 		}
 	}
+#endif
 
 	return 0;
 }
@@ -2617,7 +2687,16 @@ static int ieee80211_suspend(struct wiphy *wiphy,
 
 static int ieee80211_resume(struct wiphy *wiphy)
 {
+#if CFG80211_VERSION < KERNEL_VERSION(5,12,0)
+	int ret = __ieee80211_resume(wiphy_priv(wiphy));
+
+	if (ret)
+		cfg80211_shutdown_all_interfaces(wiphy);
+
+	return ret;
+#else
 	return __ieee80211_resume(wiphy_priv(wiphy));
+#endif
 }
 #else
 #define ieee80211_suspend NULL
@@ -4211,6 +4290,7 @@ static int ieee80211_set_multicast_to_unicast(struct wiphy *wiphy,
 	return 0;
 }
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,0)
 void ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,
 			      struct txq_info *txqi)
 {
@@ -4303,6 +4383,7 @@ out:
 
 	return ret;
 }
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(4,18,0) */
 
 static int
 ieee80211_get_ftm_responder_stats(struct wiphy *wiphy,
@@ -4564,7 +4645,11 @@ ieeee80211_obss_color_collision_notify(struct ieee80211_vif *vif,
 	if (sdata->vif.bss_conf.color_change_active || sdata->vif.bss_conf.csa_active)
 		return;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,19,0)
 	cfg80211_obss_color_collision_notify(sdata->dev, color_bitmap, gfp);
+#else
+	cfg80211_obss_color_collision_notify(sdata->dev, color_bitmap);
+#endif
 }
 EXPORT_SYMBOL_GPL(ieeee80211_obss_color_collision_notify);
 
@@ -4659,6 +4744,7 @@ static int ieee80211_set_hw_timestamp(struct wiphy *wiphy,
 	return local->ops->set_hw_timestamp(&local->hw, &sdata->vif, hwts);
 }
 
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 static int sta_add_link_station(struct ieee80211_local *local,
 				struct ieee80211_sub_if_data *sdata,
 				struct link_station_parameters *params)
@@ -4771,6 +4857,7 @@ ieee80211_del_link_station(struct wiphy *wiphy, struct net_device *dev,
 	return ret;
 }
 
+#endif
 const struct cfg80211_ops mac80211_config_ops = {
 	.add_virtual_intf = ieee80211_add_iface,
 	.del_virtual_intf = ieee80211_del_iface,
@@ -4866,7 +4953,9 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.del_nan_func = ieee80211_del_nan_func,
 	.set_multicast_to_unicast = ieee80211_set_multicast_to_unicast,
 	.tx_control_port = ieee80211_tx_control_port,
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,0)
 	.get_txq_stats = ieee80211_get_txq_stats,
+#endif
 	.get_ftm_responder_stats = ieee80211_get_ftm_responder_stats,
 	.start_pmsr = ieee80211_start_pmsr,
 	.abort_pmsr = ieee80211_abort_pmsr,
@@ -4879,7 +4968,9 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.add_intf_link = ieee80211_add_intf_link,
 	.del_intf_link = ieee80211_del_intf_link,
 	.set_hw_timestamp = ieee80211_set_hw_timestamp,
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	.add_link_station = ieee80211_add_link_station,
 	.mod_link_station = ieee80211_mod_link_station,
 	.del_link_station = ieee80211_del_link_station,
+#endif
 };
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 7e40dba48b..c2517d2b3a 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -426,10 +426,14 @@ static ssize_t reset_write(struct file *file, const char __user *user_buf,
 	int ret;
 
 	rtnl_lock();
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(local->hw.wiphy);
+#endif
 	__ieee80211_suspend(&local->hw, NULL);
 	ret = __ieee80211_resume(&local->hw);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(local->hw.wiphy);
+#endif
 
 	if (ret)
 		cfg80211_shutdown_all_interfaces(local->hw.wiphy);
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 6428e8be54..4fccf8f870 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1303,7 +1303,11 @@ struct ieee80211_local {
 	/* number of interfaces with corresponding FIF_ flags */
 	int fif_fcsfail, fif_plcpfail, fif_control, fif_other_bss, fif_pspoll,
 	    fif_probe_req;
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 	bool probe_req_reg;
+#else
+	unsigned int probe_req_reg;
+#endif
 	bool rx_mcast_action_reg;
 	unsigned int filter_flags; /* FIF_* */
 
@@ -2323,8 +2327,10 @@ void ieee80211_txq_purge(struct ieee80211_local *local,
 			 struct txq_info *txqi);
 void ieee80211_txq_remove_vlan(struct ieee80211_local *local,
 			       struct ieee80211_sub_if_data *sdata);
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,0)
 void ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,
 			      struct txq_info *txqi);
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(4,18,0) */
 void ieee80211_wake_txqs(struct tasklet_struct *t);
 void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
 			 u16 transaction, u16 auth_alg, u16 status,
@@ -2396,9 +2402,11 @@ int ieee80211_add_ext_srates_ie(struct ieee80211_sub_if_data *sdata,
 				struct sk_buff *skb, bool need_basic,
 				enum nl80211_band band);
 u8 *ieee80211_add_wmm_info_ie(u8 *buf, u8 qosinfo);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 void ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,
 				struct ieee80211_sta_s1g_cap *caps,
 				struct sk_buff *skb);
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,10,0) */
 void ieee80211_add_aid_request_ie(struct ieee80211_sub_if_data *sdata,
 				  struct sk_buff *skb);
 
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 540c466666..ddeedf7531 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -361,9 +361,13 @@ static int ieee80211_open(struct net_device *dev)
 	if (err)
 		return err;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(sdata->local->hw.wiphy);
+#endif
 	err = ieee80211_do_open(&sdata->wdev, true);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(sdata->local->hw.wiphy);
+#endif
 
 	return err;
 }
@@ -925,9 +931,13 @@ static int ieee80211_stop(struct net_device *dev)
 		ieee80211_stop_mbssid(sdata);
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(sdata->local->hw.wiphy);
+#endif
 	ieee80211_do_stop(sdata, true);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(sdata->local->hw.wiphy);
+#endif
 
 	return 0;
 }
@@ -2590,13 +2600,17 @@ void ieee80211_remove_interfaces(struct ieee80211_local *local)
 
 	unregister_netdevice_many(&unreg_list);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(local->hw.wiphy);
+#endif
 	list_for_each_entry_safe(sdata, tmp, &wdev_list, list) {
 		list_del(&sdata->list);
 		cfg80211_unregister_wdev(&sdata->wdev);
 		kfree(sdata);
 	}
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(local->hw.wiphy);
+#endif
 }
 
 static int netdev_notify(struct notifier_block *nb,
--- a/net/mac80211/link.c
+++ b/net/mac80211/link.c
@@ -403,6 +407,7 @@ static void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
 
 	if (!deflink) {
 		switch (sdata->vif.type) {
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 		case NL80211_IFTYPE_AP:
 			ether_addr_copy(link_conf->addr,
 					sdata->wdev.links[link_id].addr);
@@ -412,6 +417,7 @@ static void ieee80211_link_init(struct ieee80211_sub_if_data *sdata,
 		case NL80211_IFTYPE_STATION:
 			/* station sets the bssid in ieee80211_mgd_setup_link */
 			break;
+#endif
 		default:
 			WARN_ON(1);
 		}
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index ffdedc3d37..c1ce3fdcda 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -341,7 +341,9 @@ static void ieee80211_restart_work(struct work_struct *work)
 
 	/* we might do interface manipulations, so need both */
 	rtnl_lock();
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(local->hw.wiphy);
+#endif
 
 	WARN(test_bit(SCAN_HW_SCANNING, &local->scanning),
 	     "%s called with hardware scan in progress\n", __func__);
@@ -384,7 +386,9 @@ static void ieee80211_restart_work(struct work_struct *work)
 	synchronize_net();
 
 	ret = ieee80211_reconfig(local);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(local->hw.wiphy);
+#endif
 
 	if (ret)
 		cfg80211_shutdown_all_interfaces(local->hw.wiphy);
@@ -1262,6 +1266,7 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 	if (ieee80211_hw_check(&local->hw, CHANCTX_STA_CSA))
 		local->ext_capa[0] |= WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,1,0)
 	/* mac80211 supports multi BSSID, if the driver supports it */
 	if (ieee80211_hw_check(&local->hw, SUPPORTS_MULTI_BSSID)) {
 		local->hw.wiphy->support_mbssid = true;
@@ -1272,6 +1277,7 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 			local->ext_capa[2] |=
 				WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;
 	}
+#endif
 
 	local->hw.wiphy->max_num_csa_counters = IEEE80211_MAX_CNTDWN_COUNTERS_NUM;
 
@@ -1389,7 +1395,9 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 	rate_control_add_debugfs(local);
 
 	rtnl_lock();
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(hw->wiphy);
+#endif
 
 	/* add one default STA interface if supported */
 	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION) &&
@@ -1403,7 +1411,9 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 				   "Failed to add default virtual iface\n");
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(hw->wiphy);
+#endif
 	rtnl_unlock();
 
 #ifdef CONFIG_INET
diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c
index 6678655d0f..33a368a024 100644
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -1254,13 +1254,26 @@ static size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,
 	if (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))
 		ieee80211_add_eht_ie(sdata, skb, sband);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 	if (sband->band == NL80211_BAND_S1GHZ) {
 		ieee80211_add_aid_request_ie(sdata, skb);
 		ieee80211_add_s1g_capab_ie(sdata, &sband->s1g_cap, skb);
 	}
+#endif
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,14,0)
 	if (iftd && iftd->vendor_elems.data && iftd->vendor_elems.len)
 		skb_put_data(skb, iftd->vendor_elems.data, iftd->vendor_elems.len);
+#else
+	if (iftd) {
+		/* iftd assigned means HE is supported, so we want this */
+		static const u8 iwl_vendor_elem[] = {
+			0xdd, 0x06, 0x00, 0x17, 0x35, 0x08, 0x01, 0x00,
+		};
+
+		skb_put_data(skb, iwl_vendor_elem, sizeof(iwl_vendor_elem));
+	}
+#endif
 
 	if (link)
 		link->u.mgd.conn_flags = assoc_data->link[link_id].conn_flags;
@@ -1459,7 +1472,9 @@ static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
 
 	for (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {
 		struct cfg80211_bss *cbss = assoc_data->link[link_id].bss;
+#if CFG80211_VERSION >= KERNEL_VERSION(5,14,0)
 		const struct ieee80211_sband_iftype_data *iftd;
+#endif
 		struct ieee80211_supported_band *sband;
 
 		if (!cbss)
@@ -1475,9 +1490,14 @@ static int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)
 		/* supported channels */
 		size += 2 + 2 * sband->n_channels;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,14,0)
 		iftd = ieee80211_get_sband_iftype_data(sband, iftype);
 		if (iftd)
 			size += iftd->vendor_elems.len;
+#else
+		/* special Intel vendor element */
+		size += 8;
+#endif
 
 		/* power capability */
 		size += 4;
@@ -2096,9 +2116,11 @@ ieee80211_find_80211h_pwr_constr(struct ieee80211_sub_if_data *sdata,
 		fallthrough;
 	case NL80211_BAND_2GHZ:
 	case NL80211_BAND_60GHZ:
+#if CFG80211_VERSION >= KERNEL_VERSION(5,16,0)
 	case NL80211_BAND_LC:
 		chan_increment = 1;
 		break;
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,16,0) */
 	case NL80211_BAND_5GHZ:
 		chan_increment = 4;
 		break;
@@ -4249,13 +4271,19 @@ static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,
 		bss_conf->he_bss_color.partial =
 			le32_get_bits(elems->he_operation->he_oper_params,
 				      IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,4,0)
 		bss_conf->he_bss_color.enabled =
 			!le32_get_bits(elems->he_operation->he_oper_params,
 				       IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);
 
 		if (bss_conf->he_bss_color.enabled)
 			*changed |= BSS_CHANGED_HE_BSS_COLOR;
-
+#else
+		bss_conf->he_bss_color.disabled =
+			le32_get_bits(elems->he_operation->he_oper_params,
+				      IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);
+		*changed |= BSS_CHANGED_HE_BSS_COLOR;
+#endif
 		bss_conf->htc_trig_based_pkt_ext =
 			le32_get_bits(elems->he_operation->he_oper_params,
 				      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);
@@ -4272,6 +4300,7 @@ static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,
 		/* TODO: OPEN: what happens if BSS color disable is set? */
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,1,0)
 	if (cbss->transmitted_bss) {
 		bss_conf->nontransmitted = true;
 		ether_addr_copy(bss_conf->transmitter_bssid,
@@ -4279,6 +4308,7 @@ static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,
 		bss_conf->bssid_indicator = cbss->max_bssid_indicator;
 		bss_conf->bssid_index = cbss->bssid_index;
 	}
+#endif
 
 	/*
 	 * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data
@@ -5287,8 +5317,12 @@ static void ieee80211_rx_bss_info(struct ieee80211_link_data *link,
 
 	sdata_assert_lock(sdata);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 	channel = ieee80211_get_channel_khz(local->hw.wiphy,
 					ieee80211_rx_status_to_khz(rx_status));
+#else
+	channel = ieee80211_get_channel(local->hw.wiphy, rx_status->freq);
+#endif
 	if (!channel)
 		return;
 
@@ -5470,9 +5504,13 @@ static bool ieee80211_rx_our_beacon(const u8 *tx_bssid,
 {
 	if (ether_addr_equal(tx_bssid, bss->bssid))
 		return true;
+#if CFG80211_VERSION >= KERNEL_VERSION(5,1,0)
 	if (!bss->transmitted_bss)
 		return false;
 	return ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);
+#else
+	return false;
+#endif
 }
 
 static bool ieee80211_config_puncturing(struct ieee80211_link_data *link,
@@ -5561,8 +5599,12 @@ static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,
 		return;
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 	if (ieee80211_rx_status_to_khz(rx_status) !=
 	    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {
+#else
+	if (rx_status->freq != chanctx_conf->def.chan->center_freq) {
+#endif
 		rcu_read_unlock();
 		return;
 	}
@@ -6911,6 +6953,7 @@ ieee80211_setup_assoc_link(struct ieee80211_sub_if_data *sdata,
 		assoc_data->supp_rates_len = bss->supp_rates_len;
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	/* copy and link elems for the STA profile */
 	if (req->links[link_id].elems_len) {
 		memcpy(assoc_data->ie_pos, req->links[link_id].elems,
@@ -6919,6 +6962,7 @@ ieee80211_setup_assoc_link(struct ieee80211_sub_if_data *sdata,
 		assoc_data->link[link_id].elems_len = req->links[link_id].elems_len;
 		assoc_data->ie_pos += req->links[link_id].elems_len;
 	}
+#endif
 
 	rcu_read_lock();
 	ht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_OPERATION);
@@ -7208,8 +7252,11 @@ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
 		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
 	}
 
+
+#if CFG80211_VERSION >= KERNEL_VERSION(6,0,0)
 	if (req->flags & ASSOC_REQ_DISABLE_EHT)
 		conn_flags |= IEEE80211_CONN_DISABLE_EHT;
+#endif
 
 	memcpy(&ifmgd->ht_capa, &req->ht_capa, sizeof(ifmgd->ht_capa));
 	memcpy(&ifmgd->ht_capa_mask, &req->ht_capa_mask,
@@ -7219,9 +7266,11 @@ int ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,
 	memcpy(&ifmgd->vht_capa_mask, &req->vht_capa_mask,
 	       sizeof(ifmgd->vht_capa_mask));
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 	memcpy(&ifmgd->s1g_capa, &req->s1g_capa, sizeof(ifmgd->s1g_capa));
 	memcpy(&ifmgd->s1g_capa_mask, &req->s1g_capa_mask,
 	       sizeof(ifmgd->s1g_capa_mask));
+#endif
 
 	if (req->ie && req->ie_len) {
 		memcpy(assoc_data->ie, req->ie, req->ie_len);
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 1d2ed41729..c3c774d292 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -3181,8 +3181,10 @@ ieee80211_rx_check_bss_color_collision(struct ieee80211_rx_data *rx)
 	const struct element *ie;
 	size_t baselen;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,19,0)
 	if (!wiphy_ext_feature_isset(rx->local->hw.wiphy,
 				     NL80211_EXT_FEATURE_BSS_COLOR))
+#endif
 		return;
 
 	if (ieee80211_hw_check(&rx->local->hw, DETECTS_COLOR_COLLISION))
@@ -3250,10 +3252,16 @@ ieee80211_rx_h_mgmt_check(struct ieee80211_rx_data *rx)
 		    !(status->flag & RX_FLAG_NO_SIGNAL_VAL))
 			sig = status->signal;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 		cfg80211_report_obss_beacon_khz(rx->local->hw.wiphy,
 						rx->skb->data, rx->skb->len,
 						ieee80211_rx_status_to_khz(status),
 						sig);
+#else
+		cfg80211_report_obss_beacon(rx->local->hw.wiphy,
+					    rx->skb->data, rx->skb->len,
+					    status->freq, sig);
+#endif
 		rx->flags |= IEEE80211_RX_BEACON_REPORTED;
 	}
 
diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c
index 2a06c09ee9..c9fcff8581 100644
--- a/net/mac80211/scan.c
+++ b/net/mac80211/scan.c
@@ -222,6 +222,7 @@ ieee80211_bss_info_update(struct ieee80211_local *local,
 	ieee80211_update_bss_from_elems(local, bss, elems, rx_status, beacon);
 	kfree(elems);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,1,0)
 	list_for_each_entry(non_tx_cbss, &cbss->nontrans_list, nontrans_list) {
 		non_tx_bss = (void *)non_tx_cbss->priv;
 
@@ -234,6 +235,7 @@ ieee80211_bss_info_update(struct ieee80211_local *local,
 						rx_status, beacon);
 		kfree(elems);
 	}
+#endif
 
 	return bss;
 }
@@ -319,9 +321,12 @@ void ieee80211_scan_rx(struct ieee80211_local *local, struct sk_buff *skb)
 			return;
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,8,0)
 	channel = ieee80211_get_channel_khz(local->hw.wiphy,
 					ieee80211_rx_status_to_khz(rx_status));
-
+#else
+	channel = ieee80211_get_channel(local->hw.wiphy, rx_status->freq);
+#endif
 	if (!channel || channel->flags & IEEE80211_CHAN_DISABLED)
 		return;
 
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index b907ced889..b5d625bb79 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -594,6 +594,7 @@ __sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 
 		switch (i) {
 		case NL80211_BAND_2GHZ:
+#if CFG80211_VERSION >= KERNEL_VERSION(5,16,0)
 		case NL80211_BAND_LC:
 			/*
 			 * We use both here, even if we cannot really know for
@@ -607,6 +608,7 @@ __sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 			mandatory = IEEE80211_RATE_MANDATORY_B |
 				    IEEE80211_RATE_MANDATORY_G;
 			break;
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,16,0) */
 		case NL80211_BAND_5GHZ:
 			mandatory = IEEE80211_RATE_MANDATORY_A;
 			break;
@@ -2288,19 +2290,27 @@ static void sta_stats_decode_rate(struct ieee80211_local *local, u32 rate,
 		break;
 		}
 	case STA_STATS_RATE_TYPE_HE:
+#if CFG80211_VERSION >= KERNEL_VERSION(4,19,0)
 		rinfo->flags = RATE_INFO_FLAGS_HE_MCS;
 		rinfo->mcs = STA_STATS_GET(HE_MCS, rate);
 		rinfo->nss = STA_STATS_GET(HE_NSS, rate);
 		rinfo->he_gi = STA_STATS_GET(HE_GI, rate);
 		rinfo->he_ru_alloc = STA_STATS_GET(HE_RU, rate);
 		rinfo->he_dcm = STA_STATS_GET(HE_DCM, rate);
+#else
+		WARN_ONCE(1, "HE not supported on this cfg80211 version\n");
+#endif
 		break;
+#if CFG80211_VERSION >= KERNEL_VERSION(5,18,0)
 	case STA_STATS_RATE_TYPE_EHT:
 		rinfo->flags = RATE_INFO_FLAGS_EHT_MCS;
 		rinfo->mcs = STA_STATS_GET(EHT_MCS, rate);
 		rinfo->nss = STA_STATS_GET(EHT_NSS, rate);
 		rinfo->eht_gi = STA_STATS_GET(EHT_GI, rate);
 		rinfo->eht_ru_alloc = STA_STATS_GET(EHT_RU, rate);
+#else
+		WARN_ONCE(1, "EHT not supported on this cfg80211 version\n");
+#endif
 		break;
 	}
 }
@@ -2372,6 +2382,7 @@ static void sta_set_tidstats(struct sta_info *sta,
 		tidstats->tx_msdu_failed = sta->deflink.status_stats.msdu_failed[tid];
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,0)
 	if (local->ops->wake_tx_queue && tid < IEEE80211_NUM_TIDS) {
 		spin_lock_bh(&local->fq.lock);
 		rcu_read_lock();
@@ -2383,6 +2394,7 @@ static void sta_set_tidstats(struct sta_info *sta,
 		rcu_read_unlock();
 		spin_unlock_bh(&local->fq.lock);
 	}
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(4,18,0) */
 }
 
 static inline u64 sta_get_stats_bytes(struct ieee80211_sta_rx_stats *rxstats)
@@ -2493,6 +2505,7 @@ void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,1,0)
 	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_DURATION))) {
 		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
 			sinfo->rx_duration += sta->airtime[ac].rx_airtime;
@@ -2509,6 +2522,7 @@ void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		sinfo->airtime_weight = sta->airtime_weight;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT);
 	}
+#endif
 
 	sinfo->rx_dropped_misc = sta->deflink.rx_stats.dropped;
 	if (sta->deflink.pcpu_rx_stats) {
@@ -2647,12 +2661,15 @@ void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		sinfo->expected_throughput = thr;
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,17,0)
 	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL)) &&
 	    sta->deflink.status_stats.ack_signal_filled) {
 		sinfo->ack_signal = sta->deflink.status_stats.last_ack_signal;
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);
 	}
+#endif
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,20,0)
 	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG)) &&
 	    sta->deflink.status_stats.ack_signal_filled) {
 		sinfo->avg_ack_signal =
@@ -2661,12 +2678,15 @@ void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		sinfo->filled |=
 			BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);
 	}
+#endif
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_LINK_METRIC);
 		sinfo->airtime_link_metric =
 			airtime_link_metric_get(local, sta);
 	}
+#endif
 }
 
 u32 sta_get_expected_throughput(struct sta_info *sta)
diff --git a/net/mac80211/status.c b/net/mac80211/status.c
index a0ab3c838e..dc3b4c2cff 100644
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -430,6 +430,9 @@ ieee80211_add_tx_radiotap_header(struct ieee80211_local *local,
 	} else if (status_rate && (status_rate->rate_idx.flags &
 					RATE_INFO_FLAGS_HE_MCS))
 	{
+#if CFG80211_VERSION < KERNEL_VERSION(4,19,0)
+		WARN_ON_ONCE(1);
+#else
 		struct ieee80211_radiotap_he *he;
 
 		rthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_HE));
@@ -500,6 +503,7 @@ ieee80211_add_tx_radiotap_header(struct ieee80211_local *local,
 		}
 
 		pos += sizeof(struct ieee80211_radiotap_he);
+#endif
 	}
 
 	if (status_rate || info->status.rates[0].idx < 0)
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index be77b77201..697201d892 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -45,10 +45,10 @@
 			__field(u32, center_freq2)
 #define CHANDEF_ASSIGN(c)							\
 			__entry->control_freq = (c) ? ((c)->chan ? (c)->chan->center_freq : 0) : 0;	\
-			__entry->freq_offset = (c) ? ((c)->chan ? (c)->chan->freq_offset : 0) : 0;	\
+			__entry->freq_offset = (c) ? ((c)->chan ? cfg80211_chan_freq_offset((c)->chan) : 0) : 0;	\
 			__entry->chan_width = (c) ? (c)->width : 0;			\
 			__entry->center_freq1 = (c) ? (c)->center_freq1 : 0;		\
-			__entry->freq1_offset = (c) ? (c)->freq1_offset : 0;		\
+			__entry->freq1_offset = (c) ? cfg80211_chandef_freq1_offset((c)) : 0;		\
 			__entry->center_freq2 = (c) ? (c)->center_freq2 : 0;
 #define CHANDEF_PR_FMT	" control:%d.%03d MHz width:%d center: %d.%03d/%d MHz"
 #define CHANDEF_PR_ARG	__entry->control_freq, __entry->freq_offset, __entry->chan_width, \
@@ -64,10 +64,10 @@
 
 #define MIN_CHANDEF_ASSIGN(c)								\
 			__entry->min_control_freq = (c)->chan ? (c)->chan->center_freq : 0;	\
-			__entry->min_freq_offset = (c)->chan ? (c)->chan->freq_offset : 0;	\
+			__entry->min_freq_offset = (c)->chan ? cfg80211_chan_freq_offset((c)->chan) : 0;	\
 			__entry->min_chan_width = (c)->width;				\
 			__entry->min_center_freq1 = (c)->center_freq1;			\
-			__entry->freq1_offset = (c)->freq1_offset;			\
+			__entry->freq1_offset = cfg80211_chandef_freq1_offset((c));			\
 			__entry->min_center_freq2 = (c)->center_freq2;
 #define MIN_CHANDEF_PR_FMT	" min_control:%d.%03d MHz min_width:%d min_center: %d.%03d/%d MHz"
 #define MIN_CHANDEF_PR_ARG	__entry->min_control_freq, __entry->min_freq_offset,	\
@@ -505,7 +505,7 @@ TRACE_EVENT(drv_link_info_changed,
 		__entry->cqm_rssi_hyst = link_conf->cqm_rssi_hyst;
 		__entry->channel_width = link_conf->chandef.width;
 		__entry->channel_cfreq1 = link_conf->chandef.center_freq1;
-		__entry->channel_cfreq1_offset = link_conf->chandef.freq1_offset;
+		__entry->channel_cfreq1_offset = cfg80211_chandef_freq1_offset(&link_conf->chandef);
 		__entry->qos = link_conf->qos;
 		__entry->hidden_ssid = link_conf->hidden_ssid;
 		__entry->txpower = link_conf->txpower;
@@ -1282,7 +1282,7 @@ TRACE_EVENT(drv_remain_on_channel,
 		LOCAL_ASSIGN;
 		VIF_ASSIGN;
 		__entry->center_freq = chan->center_freq;
-		__entry->freq_offset = chan->freq_offset;
+		__entry->freq_offset = cfg80211_chan_freq_offset(chan);
 		__entry->duration = duration;
 		__entry->type = type;
 	),
@@ -1675,26 +1675,26 @@ TRACE_EVENT(drv_switch_vif_chanctx,
 					sizeof(local_vifs[i].vif.vif_name));
 				SWITCH_ENTRY_ASSIGN(old_chandef.control_freq,
 						old_ctx->def.chan->center_freq);
-				SWITCH_ENTRY_ASSIGN(old_chandef.freq_offset,
-						old_ctx->def.chan->freq_offset);
+				local_vifs[i].old_chandef.freq_offset =
+					cfg80211_chan_freq_offset(vifs[i].old_ctx->def.chan);
 				SWITCH_ENTRY_ASSIGN(old_chandef.chan_width,
 						    old_ctx->def.width);
 				SWITCH_ENTRY_ASSIGN(old_chandef.center_freq1,
 						    old_ctx->def.center_freq1);
-				SWITCH_ENTRY_ASSIGN(old_chandef.freq1_offset,
-						    old_ctx->def.freq1_offset);
+				local_vifs[i].old_chandef.freq1_offset =
+					cfg80211_chandef_freq1_offset(&vifs[i].old_ctx->def);
 				SWITCH_ENTRY_ASSIGN(old_chandef.center_freq2,
 						    old_ctx->def.center_freq2);
 				SWITCH_ENTRY_ASSIGN(new_chandef.control_freq,
 						new_ctx->def.chan->center_freq);
-				SWITCH_ENTRY_ASSIGN(new_chandef.freq_offset,
-						new_ctx->def.chan->freq_offset);
+				local_vifs[i].new_chandef.freq_offset =
+					cfg80211_chan_freq_offset(vifs[i].new_ctx->def.chan);
 				SWITCH_ENTRY_ASSIGN(new_chandef.chan_width,
 						    new_ctx->def.width);
 				SWITCH_ENTRY_ASSIGN(new_chandef.center_freq1,
 						    new_ctx->def.center_freq1);
-				SWITCH_ENTRY_ASSIGN(new_chandef.freq1_offset,
-						    new_ctx->def.freq1_offset);
+				local_vifs[i].new_chandef.freq1_offset =
+					cfg80211_chandef_freq1_offset(&vifs[i].new_ctx->def);
 				SWITCH_ENTRY_ASSIGN(new_chandef.center_freq2,
 						    new_ctx->def.center_freq2);
 			}
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index f16ec4cd7a..3ae7f20eaa 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -146,6 +146,7 @@ static __le16 ieee80211_duration(struct ieee80211_tx_data *tx,
 
 		switch (sband->band) {
 		case NL80211_BAND_2GHZ:
+#if CFG80211_VERSION >= KERNEL_VERSION(5,16,0)
 		case NL80211_BAND_LC: {
 			u32 flag;
 			if (tx->sdata->deflink.operating_11g_mode)
@@ -156,6 +157,7 @@ static __le16 ieee80211_duration(struct ieee80211_tx_data *tx,
 				mrate = r->bitrate;
 			break;
 		}
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,16,0) */
 		case NL80211_BAND_5GHZ:
 		case NL80211_BAND_6GHZ:
 			if (r->flags & IEEE80211_RATE_MANDATORY_A)
@@ -1537,6 +1539,7 @@ void ieee80211_txq_purge(struct ieee80211_local *local,
 	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
 }
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,0)
 void ieee80211_txq_set_params(struct ieee80211_local *local)
 {
 	if (local->hw.wiphy->txq_limit)
@@ -1554,6 +1557,7 @@ void ieee80211_txq_set_params(struct ieee80211_local *local)
 	else
 		local->hw.wiphy->txq_quantum = local->fq.quantum;
 }
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(4,18,0) */
 
 int ieee80211_txq_setup_flows(struct ieee80211_local *local)
 {
@@ -1604,7 +1608,9 @@ int ieee80211_txq_setup_flows(struct ieee80211_local *local)
 	for (i = 0; i < fq->flows_cnt; i++)
 		codel_vars_init(&local->cvars[i]);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,0)
 	ieee80211_txq_set_params(local);
+#endif
 
 	return 0;
 }
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index 491d094d8d..8d61907846 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -64,11 +64,13 @@ u8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,
 		return hdr->addr3;
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 	if (ieee80211_is_s1g_beacon(fc)) {
 		struct ieee80211_ext *ext = (void *) hdr;
 
 		return ext->u.s1g_beacon.sa;
 	}
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,10,0) */
 
 	if (ieee80211_is_mgmt(fc)) {
 		if (len < 24) /* drop incorrect hdr len (mgmt) */
@@ -1048,10 +1050,12 @@ _ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params,
 		u8 elen = elem->datalen;
 		const u8 *pos = elem->data;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
 		if (check_inherit &&
 		    !cfg80211_is_element_inherited(elem,
 						   check_inherit))
 			continue;
+#endif
 
 		switch (id) {
 		case WLAN_EID_SSID:
@@ -1387,6 +1391,7 @@ _ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params,
 								&crc : NULL,
 							  elem, elems);
 			break;
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 		case WLAN_EID_S1G_CAPABILITIES:
 			if (elen >= sizeof(*elems->s1g_capab))
 				elems->s1g_capab = (void *)pos;
@@ -1405,6 +1410,7 @@ _ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params,
 			else
 				elem_parse_failed = true;
 			break;
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,10,0) */
 		case WLAN_EID_AID_RESPONSE:
 			if (elen == sizeof(struct ieee80211_aid_response_ie))
 				elems->aid_resp = (void *)pos;
@@ -1432,6 +1438,7 @@ static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,
 					    struct cfg80211_bss *bss,
 					    u8 *nontransmitted_profile)
 {
+#if CFG80211_VERSION >= KERNEL_VERSION(5,2,0)
 	const struct element *elem, *sub;
 	size_t profile_len = 0;
 	bool found = false;
@@ -1492,6 +1499,9 @@ static size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,
 	}
 
 	return found ? profile_len : 0;
+#else
+	return 0;
+#endif
 }
 
 struct ieee802_11_elems *
@@ -1570,6 +1580,7 @@ void ieee80211_regulatory_limit_wmm_params(struct ieee80211_sub_if_data *sdata,
 	    sdata->vif.type != NL80211_IFTYPE_STATION)
 		return;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,17,0)
 	rcu_read_lock();
 	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
 	if (chanctx_conf)
@@ -1582,20 +1593,33 @@ void ieee80211_regulatory_limit_wmm_params(struct ieee80211_sub_if_data *sdata,
 
 	rrule = freq_reg_info(sdata->wdev.wiphy, MHZ_TO_KHZ(center_freq));
 
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,13)
 	if (IS_ERR_OR_NULL(rrule) || !rrule->has_wmm) {
+#else
+	if (IS_ERR_OR_NULL(rrule) || !rrule->wmm_rule) {
+#endif
 		rcu_read_unlock();
 		return;
 	}
 
 	if (sdata->vif.type == NL80211_IFTYPE_AP)
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,13)
 		wmm_ac = &rrule->wmm_rule.ap[ac];
+#else
+		wmm_ac = &rrule->wmm_rule->ap[ac];
+#endif
 	else
+#if CFG80211_VERSION >= KERNEL_VERSION(4,18,13)
 		wmm_ac = &rrule->wmm_rule.client[ac];
+#else
+		wmm_ac = &rrule->wmm_rule->client[ac];
+#endif
 	qparam->cw_min = max_t(u16, qparam->cw_min, wmm_ac->cw_min);
 	qparam->cw_max = max_t(u16, qparam->cw_max, wmm_ac->cw_max);
 	qparam->aifs = max_t(u8, qparam->aifs, wmm_ac->aifsn);
 	qparam->txop = min_t(u16, qparam->txop, wmm_ac->cot / 32);
 	rcu_read_unlock();
+#endif
 }
 
 void ieee80211_set_wmm_default(struct ieee80211_link_data *link,
@@ -2030,6 +2054,7 @@ static int ieee80211_build_preq_ies_band(struct ieee80211_sub_if_data *sdata,
 			goto out_err;
 	}
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,4,0)
 	if (cfg80211_any_usable_channels(local->hw.wiphy,
 					 BIT(NL80211_BAND_6GHZ),
 					 IEEE80211_CHAN_NO_HE)) {
@@ -2047,6 +2072,7 @@ static int ieee80211_build_preq_ies_band(struct ieee80211_sub_if_data *sdata,
 			pos = ieee80211_write_he_6ghz_cap(pos, cap, end);
 		}
 	}
+#endif
 
 	/*
 	 * If adding more here, adjust code in main.c
@@ -3092,12 +3118,16 @@ void ieee80211_ie_build_he_6ghz_cap(struct ieee80211_sub_if_data *sdata,
 	u8 *pos;
 	u16 cap;
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,4,0)
 	if (!cfg80211_any_usable_channels(sdata->local->hw.wiphy,
 					  BIT(NL80211_BAND_6GHZ),
 					  IEEE80211_CHAN_NO_HE))
 		return;
 
 	sband = sdata->local->hw.wiphy->bands[NL80211_BAND_6GHZ];
+#else
+	return;
+#endif
 
 	iftd = ieee80211_get_sband_iftype_data(sband, iftype);
 	if (!iftd)
@@ -3707,6 +3737,7 @@ bool ieee80211_chandef_he_6ghz_oper(struct ieee80211_sub_if_data *sdata,
 	return true;
 }
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 bool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,
 				struct cfg80211_chan_def *chandef)
 {
@@ -3742,6 +3773,7 @@ bool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,
 
 	return true;
 }
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,10,0) */
 
 int ieee80211_parse_bitrates(enum nl80211_chan_width width,
 			     const struct ieee80211_supported_band *sband,
@@ -3923,6 +3955,7 @@ u64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,
 
 	/* Fill cfg80211 rate info */
 	switch (status->encoding) {
+#if CFG80211_VERSION >= KERNEL_VERSION(5,18,0)
 	case RX_ENC_EHT:
 		ri.flags |= RATE_INFO_FLAGS_EHT_MCS;
 		ri.mcs = status->rate_idx;
@@ -3936,6 +3969,8 @@ u64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,
 			ts += 36;
 		}
 		break;
+#endif
+#if CFG80211_VERSION >= KERNEL_VERSION(4,19,0)
 	case RX_ENC_HE:
 		ri.flags |= RATE_INFO_FLAGS_HE_MCS;
 		ri.mcs = status->rate_idx;
@@ -3962,6 +3997,7 @@ u64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,
 		}
 
 		break;
+#endif
 	case RX_ENC_HT:
 		ri.mcs = status->rate_idx;
 		ri.flags |= RATE_INFO_FLAGS_MCS;
@@ -4110,10 +4146,17 @@ void ieee80211_dfs_radar_detected_work(struct work_struct *work)
 	}
 	mutex_unlock(&local->chanctx_mtx);
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_lock(local->hw.wiphy);
+#else
+	rtnl_lock();
+#endif
 	ieee80211_dfs_cac_cancel(local);
+#if CFG80211_VERSION >= KERNEL_VERSION(5,12,0)
 	wiphy_unlock(local->hw.wiphy);
-
+#else
+	rtnl_unlock();
+#endif
 	if (num_chanctx > 1)
 		/* XXX: multi-channel is not supported yet */
 		WARN_ON(1);
@@ -4666,6 +4709,7 @@ int ieee80211_max_num_channels(struct ieee80211_local *local)
 	return max_num_different_channels;
 }
 
+#if CFG80211_VERSION >= KERNEL_VERSION(5,10,0)
 void ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,
 				struct ieee80211_sta_s1g_cap *caps,
 				struct sk_buff *skb)
@@ -4707,6 +4751,7 @@ void ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,
 
 	memcpy(pos, &s1g_capab, sizeof(s1g_capab));
 }
+#endif /* CFG80211_VERSION >= KERNEL_VERSION(5,10,0) */
 
 void ieee80211_add_aid_request_ie(struct ieee80211_sub_if_data *sdata,
 				  struct sk_buff *skb)
